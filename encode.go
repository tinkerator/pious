package pious

import (
	"fmt"
	"strings"
)

// MakePackage generates the source code for a tinygo compatible
// API to some PIO program encoded in the form of a *Program.
func (p *Program) MakePackage(comment string) []string {
	lines := strings.Split(fmt.Sprint(`// Package `, p.Attr.Name, ` was autogenerated by the zappem.net/pub/io/pious package.
//
// `, comment, `

package `, p.Attr.Name, `

import (
	"machine"
	"sync"

	pio "github.com/tinygo-org/pio/rp2-pio"
)

// Engine is a wrapper type to enable `, p.Attr.Name, ` methods for a
// pio.PIO.
type Engine struct {
	block  *pio.PIO
	offset uint8
	mu     sync.Mutex
}

// StateMachine is a wrapper type to enable `, p.Attr.Name, ` methods
// for a pio.StateMachine.
type StateMachine struct {
	Origin uint8
	SM     *pio.StateMachine
	Cfg    pio.StateMachineConfig
}

// Start initializes and starts a StateMachine running a configured
// PIO sequence.
func (s *StateMachine) Start() {
	s.SM.Init(s.Origin, s.Cfg)
}

// Activate can be used to pause or resume a StateMachine.
func (s *StateMachine) Activate(run bool) {
	s.SM.SetEnabled(run)
}

// Assign loads the package program code into the block PIO.
func Assign(block *pio.PIO) (*Engine, error) {
	offset, err := block.AddProgram([]uint16{`), "\n")
	for _, code := range p.Code {
		lines = append(lines, fmt.Sprintf("\t\t0x%04x,", code))
	}
	lines = append(lines, strings.Split(`	}, -1)
	if err != nil {
		return nil, err
	}
	return &Engine{
		block:  block,
		offset: offset,
	}, nil
}
`, "\n")...)
	mods := p.Modules
	if mods == nil {
		mods = []Settings{p.Attr}
	}
	for _, m := range mods {
		fn := camelCase("Configure_" + m.Name)
		var args []string
		if m.SideSet != 0 {
			args = append(args, "sideSetBase")
		}
		args = append(args, "pinBase machine.Pin")
		lines = append(lines, strings.Split(fmt.Sprint(`// `, fn, ` sets up a `, m.Name, ` module. It operates with
// a side-set size of `, m.SideSet, ` and pins set size of `, m.Set, ` bits.
func (e *Engine) `, fn, `(`, strings.Join(args, ", "), `) (*StateMachine, error) {
	sm, err := e.block.ClaimStateMachine()
	if err != nil {
		return nil, err
	}
	pin := pinBase
	for i := 0; i < `, m.Set, `; i++ {
		pin.Configure(machine.PinConfig{Mode: e.block.PinMode()})
		pin++
	}
	sm.SetPindirsConsecutive(pinBase, `, m.Set, `, true)

	// Configure Origin and Wraps, SideSet etc
	cfg := pio.DefaultStateMachineConfig()
	cfg.SetWrap(e.offset+`, m.WrapTarget, `, e.offset+`, m.Wrap, `)
	cfg.SetSetPins(pinBase, `, m.Set, `)`), "\n")...)

		if m.SideSet != 0 {
			lines = append(lines, fmt.Sprint(`	pin = sideSetBase
	for i := 0; i < `, m.SideSet, `; i++ {
		pin.Configure(machine.PinConfig{Mode: e.block.PinMode()})
		pin++
	}
	sm.SetPindirsConsecutive(sideSetBase, `, m.SideSet, `, true)
	cfg.SetSidesetPins(sideSetBase, `, m.SideSet, `)`))
			if m.SideSetOpt || m.SideSetPindirs {
				bitCount := m.SideSet
				if m.SideSetOpt {
					bitCount++
				}
				lines = append(lines, fmt.Sprint(`	cfg.SetSidesetParams(`, bitCount, `, `, m.SideSetOpt, `, `, m.SideSetPindirs, `)`))
			}
		}

		lines = append(lines, strings.Split(fmt.Sprint(`	return &StateMachine{
		Origin: e.offset + `, m.Origin, `,
		SM:     &sm,
		Cfg:    cfg,
	}, nil
}
`), "\n")...)
	}
	return lines
}
